{
  "version": 3,
  "sources": ["../../react-router/dist/development/dom-export.mjs"],
  "sourcesContent": ["/**\r\n * react-router v7.13.0\r\n *\r\n * Copyright (c) Remix Software Inc.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE.md file in the root directory of this source tree.\r\n *\r\n * @license MIT\r\n */\r\n\"use client\";\r\nimport {\r\n  RSCRouterGlobalErrorBoundary,\r\n  deserializeErrors,\r\n  getHydrationData,\r\n  populateRSCRouteModules\r\n} from \"./chunk-4LKRSAEJ.mjs\";\r\nimport {\r\n  CRITICAL_CSS_DATA_ATTRIBUTE,\r\n  ErrorResponseImpl,\r\n  FrameworkContext,\r\n  RSCRouterContext,\r\n  RemixErrorBoundary,\r\n  RouterProvider,\r\n  createBrowserHistory,\r\n  createClientRoutes,\r\n  createClientRoutesWithHMRRevalidationOptOut,\r\n  createContext,\r\n  createRequestInit,\r\n  createRouter,\r\n  decodeViaTurboStream,\r\n  getPatchRoutesOnNavigationFunction,\r\n  getSingleFetchDataStrategyImpl,\r\n  getTurboStreamSingleFetchDataStrategy,\r\n  hydrationRouteProperties,\r\n  invariant,\r\n  isMutationMethod,\r\n  mapRouteProperties,\r\n  noActionDefinedError,\r\n  setIsHydrated,\r\n  shouldHydrateRouteLoader,\r\n  singleFetchUrl,\r\n  stripIndexParam,\r\n  useFogOFWarDiscovery\r\n} from \"./chunk-JZWAC4HX.mjs\";\r\n\r\n// lib/dom-export/dom-router-provider.tsx\r\nimport * as React from \"react\";\r\nimport * as ReactDOM from \"react-dom\";\r\nfunction RouterProvider2(props) {\r\n  return /* @__PURE__ */ React.createElement(RouterProvider, { flushSync: ReactDOM.flushSync, ...props });\r\n}\r\n\r\n// lib/dom-export/hydrated-router.tsx\r\nimport * as React2 from \"react\";\r\nvar ssrInfo = null;\r\nvar router = null;\r\nfunction initSsrInfo() {\r\n  if (!ssrInfo && window.__reactRouterContext && window.__reactRouterManifest && window.__reactRouterRouteModules) {\r\n    if (window.__reactRouterManifest.sri === true) {\r\n      const importMap = document.querySelector(\"script[rr-importmap]\");\r\n      if (importMap?.textContent) {\r\n        try {\r\n          window.__reactRouterManifest.sri = JSON.parse(\r\n            importMap.textContent\r\n          ).integrity;\r\n        } catch (err) {\r\n          console.error(\"Failed to parse import map\", err);\r\n        }\r\n      }\r\n    }\r\n    ssrInfo = {\r\n      context: window.__reactRouterContext,\r\n      manifest: window.__reactRouterManifest,\r\n      routeModules: window.__reactRouterRouteModules,\r\n      stateDecodingPromise: void 0,\r\n      router: void 0,\r\n      routerInitialized: false\r\n    };\r\n  }\r\n}\r\nfunction createHydratedRouter({\r\n  getContext,\r\n  unstable_instrumentations\r\n}) {\r\n  initSsrInfo();\r\n  if (!ssrInfo) {\r\n    throw new Error(\r\n      \"You must be using the SSR features of React Router in order to skip passing a `router` prop to `<RouterProvider>`\"\r\n    );\r\n  }\r\n  let localSsrInfo = ssrInfo;\r\n  if (!ssrInfo.stateDecodingPromise) {\r\n    let stream = ssrInfo.context.stream;\r\n    invariant(stream, \"No stream found for single fetch decoding\");\r\n    ssrInfo.context.stream = void 0;\r\n    ssrInfo.stateDecodingPromise = decodeViaTurboStream(stream, window).then((value) => {\r\n      ssrInfo.context.state = value.value;\r\n      localSsrInfo.stateDecodingPromise.value = true;\r\n    }).catch((e) => {\r\n      localSsrInfo.stateDecodingPromise.error = e;\r\n    });\r\n  }\r\n  if (ssrInfo.stateDecodingPromise.error) {\r\n    throw ssrInfo.stateDecodingPromise.error;\r\n  }\r\n  if (!ssrInfo.stateDecodingPromise.value) {\r\n    throw ssrInfo.stateDecodingPromise;\r\n  }\r\n  let routes = createClientRoutes(\r\n    ssrInfo.manifest.routes,\r\n    ssrInfo.routeModules,\r\n    ssrInfo.context.state,\r\n    ssrInfo.context.ssr,\r\n    ssrInfo.context.isSpaMode\r\n  );\r\n  let hydrationData = void 0;\r\n  if (ssrInfo.context.isSpaMode) {\r\n    let { loaderData } = ssrInfo.context.state;\r\n    if (ssrInfo.manifest.routes.root?.hasLoader && loaderData && \"root\" in loaderData) {\r\n      hydrationData = {\r\n        loaderData: {\r\n          root: loaderData.root\r\n        }\r\n      };\r\n    }\r\n  } else {\r\n    hydrationData = getHydrationData({\r\n      state: ssrInfo.context.state,\r\n      routes,\r\n      getRouteInfo: (routeId) => ({\r\n        clientLoader: ssrInfo.routeModules[routeId]?.clientLoader,\r\n        hasLoader: ssrInfo.manifest.routes[routeId]?.hasLoader === true,\r\n        hasHydrateFallback: ssrInfo.routeModules[routeId]?.HydrateFallback != null\r\n      }),\r\n      location: window.location,\r\n      basename: window.__reactRouterContext?.basename,\r\n      isSpaMode: ssrInfo.context.isSpaMode\r\n    });\r\n    if (hydrationData && hydrationData.errors) {\r\n      hydrationData.errors = deserializeErrors(hydrationData.errors);\r\n    }\r\n  }\r\n  let router2 = createRouter({\r\n    routes,\r\n    history: createBrowserHistory(),\r\n    basename: ssrInfo.context.basename,\r\n    getContext,\r\n    hydrationData,\r\n    hydrationRouteProperties,\r\n    unstable_instrumentations,\r\n    mapRouteProperties,\r\n    future: {\r\n      middleware: ssrInfo.context.future.v8_middleware\r\n    },\r\n    dataStrategy: getTurboStreamSingleFetchDataStrategy(\r\n      () => router2,\r\n      ssrInfo.manifest,\r\n      ssrInfo.routeModules,\r\n      ssrInfo.context.ssr,\r\n      ssrInfo.context.basename,\r\n      ssrInfo.context.future.unstable_trailingSlashAwareDataRequests\r\n    ),\r\n    patchRoutesOnNavigation: getPatchRoutesOnNavigationFunction(\r\n      ssrInfo.manifest,\r\n      ssrInfo.routeModules,\r\n      ssrInfo.context.ssr,\r\n      ssrInfo.context.routeDiscovery,\r\n      ssrInfo.context.isSpaMode,\r\n      ssrInfo.context.basename\r\n    )\r\n  });\r\n  ssrInfo.router = router2;\r\n  if (router2.state.initialized) {\r\n    ssrInfo.routerInitialized = true;\r\n    router2.initialize();\r\n  }\r\n  router2.createRoutesForHMR = /* spacer so ts-ignore does not affect the right hand of the assignment */\r\n  createClientRoutesWithHMRRevalidationOptOut;\r\n  window.__reactRouterDataRouter = router2;\r\n  return router2;\r\n}\r\nfunction HydratedRouter(props) {\r\n  if (!router) {\r\n    router = createHydratedRouter({\r\n      getContext: props.getContext,\r\n      unstable_instrumentations: props.unstable_instrumentations\r\n    });\r\n  }\r\n  let [criticalCss, setCriticalCss] = React2.useState(\r\n    process.env.NODE_ENV === \"development\" ? ssrInfo?.context.criticalCss : void 0\r\n  );\r\n  React2.useEffect(() => {\r\n    if (process.env.NODE_ENV === \"development\") {\r\n      setCriticalCss(void 0);\r\n    }\r\n  }, []);\r\n  React2.useEffect(() => {\r\n    if (process.env.NODE_ENV === \"development\" && criticalCss === void 0) {\r\n      document.querySelectorAll(`[${CRITICAL_CSS_DATA_ATTRIBUTE}]`).forEach((element) => element.remove());\r\n    }\r\n  }, [criticalCss]);\r\n  let [location2, setLocation] = React2.useState(router.state.location);\r\n  React2.useLayoutEffect(() => {\r\n    if (ssrInfo && ssrInfo.router && !ssrInfo.routerInitialized) {\r\n      ssrInfo.routerInitialized = true;\r\n      ssrInfo.router.initialize();\r\n    }\r\n  }, []);\r\n  React2.useLayoutEffect(() => {\r\n    if (ssrInfo && ssrInfo.router) {\r\n      return ssrInfo.router.subscribe((newState) => {\r\n        if (newState.location !== location2) {\r\n          setLocation(newState.location);\r\n        }\r\n      });\r\n    }\r\n  }, [location2]);\r\n  invariant(ssrInfo, \"ssrInfo unavailable for HydratedRouter\");\r\n  useFogOFWarDiscovery(\r\n    router,\r\n    ssrInfo.manifest,\r\n    ssrInfo.routeModules,\r\n    ssrInfo.context.ssr,\r\n    ssrInfo.context.routeDiscovery,\r\n    ssrInfo.context.isSpaMode\r\n  );\r\n  return (\r\n    // This fragment is important to ensure we match the <ServerRouter> JSX\r\n    // structure so that useId values hydrate correctly\r\n    /* @__PURE__ */ React2.createElement(React2.Fragment, null, /* @__PURE__ */ React2.createElement(\r\n      FrameworkContext.Provider,\r\n      {\r\n        value: {\r\n          manifest: ssrInfo.manifest,\r\n          routeModules: ssrInfo.routeModules,\r\n          future: ssrInfo.context.future,\r\n          criticalCss,\r\n          ssr: ssrInfo.context.ssr,\r\n          isSpaMode: ssrInfo.context.isSpaMode,\r\n          routeDiscovery: ssrInfo.context.routeDiscovery\r\n        }\r\n      },\r\n      /* @__PURE__ */ React2.createElement(RemixErrorBoundary, { location: location2 }, /* @__PURE__ */ React2.createElement(\r\n        RouterProvider2,\r\n        {\r\n          router,\r\n          unstable_useTransitions: props.unstable_useTransitions,\r\n          onError: props.onError\r\n        }\r\n      ))\r\n    ), /* @__PURE__ */ React2.createElement(React2.Fragment, null))\r\n  );\r\n}\r\n\r\n// lib/rsc/browser.tsx\r\nimport * as React3 from \"react\";\r\nimport * as ReactDOM2 from \"react-dom\";\r\nfunction createCallServer({\r\n  createFromReadableStream,\r\n  createTemporaryReferenceSet,\r\n  encodeReply,\r\n  fetch: fetchImplementation = fetch\r\n}) {\r\n  const globalVar = window;\r\n  let landedActionId = 0;\r\n  return async (id, args) => {\r\n    let actionId = globalVar.__routerActionID = (globalVar.__routerActionID ?? (globalVar.__routerActionID = 0)) + 1;\r\n    const temporaryReferences = createTemporaryReferenceSet();\r\n    const payloadPromise = fetchImplementation(\r\n      new Request(location.href, {\r\n        body: await encodeReply(args, { temporaryReferences }),\r\n        method: \"POST\",\r\n        headers: {\r\n          Accept: \"text/x-component\",\r\n          \"rsc-action-id\": id\r\n        }\r\n      })\r\n    ).then((response) => {\r\n      if (!response.body) {\r\n        throw new Error(\"No response body\");\r\n      }\r\n      return createFromReadableStream(response.body, {\r\n        temporaryReferences\r\n      });\r\n    });\r\n    React3.startTransition(\r\n      () => (\r\n        // @ts-expect-error - Needs React 19 types\r\n        Promise.resolve(payloadPromise).then(async (payload) => {\r\n          if (payload.type === \"redirect\") {\r\n            if (payload.reload || isExternalLocation(payload.location)) {\r\n              window.location.href = payload.location;\r\n              return;\r\n            }\r\n            React3.startTransition(() => {\r\n              globalVar.__reactRouterDataRouter.navigate(payload.location, {\r\n                replace: payload.replace\r\n              });\r\n            });\r\n            return;\r\n          }\r\n          if (payload.type !== \"action\") {\r\n            throw new Error(\"Unexpected payload type\");\r\n          }\r\n          const rerender = await payload.rerender;\r\n          if (rerender && landedActionId < actionId && globalVar.__routerActionID <= actionId) {\r\n            if (rerender.type === \"redirect\") {\r\n              if (rerender.reload || isExternalLocation(rerender.location)) {\r\n                window.location.href = rerender.location;\r\n                return;\r\n              }\r\n              React3.startTransition(() => {\r\n                globalVar.__reactRouterDataRouter.navigate(rerender.location, {\r\n                  replace: rerender.replace\r\n                });\r\n              });\r\n              return;\r\n            }\r\n            React3.startTransition(() => {\r\n              let lastMatch;\r\n              for (const match of rerender.matches) {\r\n                globalVar.__reactRouterDataRouter.patchRoutes(\r\n                  lastMatch?.id ?? null,\r\n                  [createRouteFromServerManifest(match)],\r\n                  true\r\n                );\r\n                lastMatch = match;\r\n              }\r\n              window.__reactRouterDataRouter._internalSetStateDoNotUseOrYouWillBreakYourApp(\r\n                {\r\n                  loaderData: Object.assign(\r\n                    {},\r\n                    globalVar.__reactRouterDataRouter.state.loaderData,\r\n                    rerender.loaderData\r\n                  ),\r\n                  errors: rerender.errors ? Object.assign(\r\n                    {},\r\n                    globalVar.__reactRouterDataRouter.state.errors,\r\n                    rerender.errors\r\n                  ) : null\r\n                }\r\n              );\r\n            });\r\n          }\r\n        }).catch(() => {\r\n        })\r\n      )\r\n    );\r\n    return payloadPromise.then((payload) => {\r\n      if (payload.type !== \"action\" && payload.type !== \"redirect\") {\r\n        throw new Error(\"Unexpected payload type\");\r\n      }\r\n      return payload.actionResult;\r\n    });\r\n  };\r\n}\r\nfunction createRouterFromPayload({\r\n  fetchImplementation,\r\n  createFromReadableStream,\r\n  getContext,\r\n  payload\r\n}) {\r\n  const globalVar = window;\r\n  if (globalVar.__reactRouterDataRouter && globalVar.__reactRouterRouteModules)\r\n    return {\r\n      router: globalVar.__reactRouterDataRouter,\r\n      routeModules: globalVar.__reactRouterRouteModules\r\n    };\r\n  if (payload.type !== \"render\") throw new Error(\"Invalid payload type\");\r\n  globalVar.__reactRouterRouteModules = globalVar.__reactRouterRouteModules ?? {};\r\n  populateRSCRouteModules(globalVar.__reactRouterRouteModules, payload.matches);\r\n  let patches = /* @__PURE__ */ new Map();\r\n  payload.patches?.forEach((patch) => {\r\n    invariant(patch.parentId, \"Invalid patch parentId\");\r\n    if (!patches.has(patch.parentId)) {\r\n      patches.set(patch.parentId, []);\r\n    }\r\n    patches.get(patch.parentId)?.push(patch);\r\n  });\r\n  let routes = payload.matches.reduceRight((previous, match) => {\r\n    const route = createRouteFromServerManifest(\r\n      match,\r\n      payload\r\n    );\r\n    if (previous.length > 0) {\r\n      route.children = previous;\r\n      let childrenToPatch = patches.get(match.id);\r\n      if (childrenToPatch) {\r\n        route.children.push(\r\n          ...childrenToPatch.map((r) => createRouteFromServerManifest(r))\r\n        );\r\n      }\r\n    }\r\n    return [route];\r\n  }, []);\r\n  globalVar.__reactRouterDataRouter = createRouter({\r\n    routes,\r\n    getContext,\r\n    basename: payload.basename,\r\n    history: createBrowserHistory(),\r\n    hydrationData: getHydrationData({\r\n      state: {\r\n        loaderData: payload.loaderData,\r\n        actionData: payload.actionData,\r\n        errors: payload.errors\r\n      },\r\n      routes,\r\n      getRouteInfo: (routeId) => {\r\n        let match = payload.matches.find((m) => m.id === routeId);\r\n        invariant(match, \"Route not found in payload\");\r\n        return {\r\n          clientLoader: match.clientLoader,\r\n          hasLoader: match.hasLoader,\r\n          hasHydrateFallback: match.hydrateFallbackElement != null\r\n        };\r\n      },\r\n      location: payload.location,\r\n      basename: payload.basename,\r\n      isSpaMode: false\r\n    }),\r\n    async patchRoutesOnNavigation({ path, signal }) {\r\n      if (discoveredPaths.has(path)) {\r\n        return;\r\n      }\r\n      await fetchAndApplyManifestPatches(\r\n        [path],\r\n        createFromReadableStream,\r\n        fetchImplementation,\r\n        signal\r\n      );\r\n    },\r\n    // FIXME: Pass `build.ssr` into this function\r\n    dataStrategy: getRSCSingleFetchDataStrategy(\r\n      () => globalVar.__reactRouterDataRouter,\r\n      true,\r\n      payload.basename,\r\n      createFromReadableStream,\r\n      fetchImplementation\r\n    )\r\n  });\r\n  if (globalVar.__reactRouterDataRouter.state.initialized) {\r\n    globalVar.__routerInitialized = true;\r\n    globalVar.__reactRouterDataRouter.initialize();\r\n  } else {\r\n    globalVar.__routerInitialized = false;\r\n  }\r\n  let lastLoaderData = void 0;\r\n  globalVar.__reactRouterDataRouter.subscribe(({ loaderData, actionData }) => {\r\n    if (lastLoaderData !== loaderData) {\r\n      globalVar.__routerActionID = (globalVar.__routerActionID ?? (globalVar.__routerActionID = 0)) + 1;\r\n    }\r\n  });\r\n  globalVar.__reactRouterDataRouter._updateRoutesForHMR = (routeUpdateByRouteId) => {\r\n    const oldRoutes = window.__reactRouterDataRouter.routes;\r\n    const newRoutes = [];\r\n    function walkRoutes(routes2, parentId) {\r\n      return routes2.map((route) => {\r\n        const routeUpdate = routeUpdateByRouteId.get(route.id);\r\n        if (routeUpdate) {\r\n          const {\r\n            routeModule,\r\n            hasAction,\r\n            hasComponent,\r\n            hasErrorBoundary,\r\n            hasLoader\r\n          } = routeUpdate;\r\n          const newRoute = createRouteFromServerManifest({\r\n            clientAction: routeModule.clientAction,\r\n            clientLoader: routeModule.clientLoader,\r\n            element: route.element,\r\n            errorElement: route.errorElement,\r\n            handle: route.handle,\r\n            hasAction,\r\n            hasComponent,\r\n            hasErrorBoundary,\r\n            hasLoader,\r\n            hydrateFallbackElement: route.hydrateFallbackElement,\r\n            id: route.id,\r\n            index: route.index,\r\n            links: routeModule.links,\r\n            meta: routeModule.meta,\r\n            parentId,\r\n            path: route.path,\r\n            shouldRevalidate: routeModule.shouldRevalidate\r\n          });\r\n          if (route.children) {\r\n            newRoute.children = walkRoutes(route.children, route.id);\r\n          }\r\n          return newRoute;\r\n        }\r\n        const updatedRoute = { ...route };\r\n        if (route.children) {\r\n          updatedRoute.children = walkRoutes(route.children, route.id);\r\n        }\r\n        return updatedRoute;\r\n      });\r\n    }\r\n    newRoutes.push(\r\n      ...walkRoutes(oldRoutes, void 0)\r\n    );\r\n    window.__reactRouterDataRouter._internalSetRoutes(newRoutes);\r\n  };\r\n  return {\r\n    router: globalVar.__reactRouterDataRouter,\r\n    routeModules: globalVar.__reactRouterRouteModules\r\n  };\r\n}\r\nvar renderedRoutesContext = createContext();\r\nfunction getRSCSingleFetchDataStrategy(getRouter, ssr, basename, createFromReadableStream, fetchImplementation) {\r\n  let dataStrategy = getSingleFetchDataStrategyImpl(\r\n    getRouter,\r\n    (match) => {\r\n      let M = match;\r\n      return {\r\n        hasLoader: M.route.hasLoader,\r\n        hasClientLoader: M.route.hasClientLoader,\r\n        hasComponent: M.route.hasComponent,\r\n        hasAction: M.route.hasAction,\r\n        hasClientAction: M.route.hasClientAction,\r\n        hasShouldRevalidate: M.route.hasShouldRevalidate\r\n      };\r\n    },\r\n    // pass map into fetchAndDecode so it can add payloads\r\n    getFetchAndDecodeViaRSC(createFromReadableStream, fetchImplementation),\r\n    ssr,\r\n    basename,\r\n    // .rsc requests are always trailing slash aware\r\n    true,\r\n    // If the route has a component but we don't have an element, we need to hit\r\n    // the server loader flow regardless of whether the client loader calls\r\n    // `serverLoader` or not, otherwise we'll have nothing to render.\r\n    (match) => {\r\n      let M = match;\r\n      return M.route.hasComponent && !M.route.element;\r\n    }\r\n  );\r\n  return async (args) => args.runClientMiddleware(async () => {\r\n    let context = args.context;\r\n    context.set(renderedRoutesContext, []);\r\n    let results = await dataStrategy(args);\r\n    const renderedRoutesById = /* @__PURE__ */ new Map();\r\n    for (const route of context.get(renderedRoutesContext)) {\r\n      if (!renderedRoutesById.has(route.id)) {\r\n        renderedRoutesById.set(route.id, []);\r\n      }\r\n      renderedRoutesById.get(route.id).push(route);\r\n    }\r\n    React3.startTransition(() => {\r\n      for (const match of args.matches) {\r\n        const renderedRoutes = renderedRoutesById.get(match.route.id);\r\n        if (renderedRoutes) {\r\n          for (const rendered of renderedRoutes) {\r\n            window.__reactRouterDataRouter.patchRoutes(\r\n              rendered.parentId ?? null,\r\n              [createRouteFromServerManifest(rendered)],\r\n              true\r\n            );\r\n          }\r\n        }\r\n      }\r\n    });\r\n    return results;\r\n  });\r\n}\r\nfunction getFetchAndDecodeViaRSC(createFromReadableStream, fetchImplementation) {\r\n  return async (args, basename, trailingSlashAware, targetRoutes) => {\r\n    let { request, context } = args;\r\n    let url = singleFetchUrl(request.url, basename, trailingSlashAware, \"rsc\");\r\n    if (request.method === \"GET\") {\r\n      url = stripIndexParam(url);\r\n      if (targetRoutes) {\r\n        url.searchParams.set(\"_routes\", targetRoutes.join(\",\"));\r\n      }\r\n    }\r\n    let res = await fetchImplementation(\r\n      new Request(url, await createRequestInit(request))\r\n    );\r\n    if (res.status >= 400 && !res.headers.has(\"X-Remix-Response\")) {\r\n      throw new ErrorResponseImpl(res.status, res.statusText, await res.text());\r\n    }\r\n    invariant(res.body, \"No response body to decode\");\r\n    try {\r\n      const payload = await createFromReadableStream(res.body, {\r\n        temporaryReferences: void 0\r\n      });\r\n      if (payload.type === \"redirect\") {\r\n        return {\r\n          status: res.status,\r\n          data: {\r\n            redirect: {\r\n              redirect: payload.location,\r\n              reload: payload.reload,\r\n              replace: payload.replace,\r\n              revalidate: false,\r\n              status: payload.status\r\n            }\r\n          }\r\n        };\r\n      }\r\n      if (payload.type !== \"render\") {\r\n        throw new Error(\"Unexpected payload type\");\r\n      }\r\n      context.get(renderedRoutesContext).push(...payload.matches);\r\n      let results = { routes: {} };\r\n      const dataKey = isMutationMethod(request.method) ? \"actionData\" : \"loaderData\";\r\n      for (let [routeId, data] of Object.entries(payload[dataKey] || {})) {\r\n        results.routes[routeId] = { data };\r\n      }\r\n      if (payload.errors) {\r\n        for (let [routeId, error] of Object.entries(payload.errors)) {\r\n          results.routes[routeId] = { error };\r\n        }\r\n      }\r\n      return { status: res.status, data: results };\r\n    } catch (e) {\r\n      throw new Error(\"Unable to decode RSC response\");\r\n    }\r\n  };\r\n}\r\nfunction RSCHydratedRouter({\r\n  createFromReadableStream,\r\n  fetch: fetchImplementation = fetch,\r\n  payload,\r\n  routeDiscovery = \"eager\",\r\n  getContext\r\n}) {\r\n  if (payload.type !== \"render\") throw new Error(\"Invalid payload type\");\r\n  let { router: router2, routeModules } = React3.useMemo(\r\n    () => createRouterFromPayload({\r\n      payload,\r\n      fetchImplementation,\r\n      getContext,\r\n      createFromReadableStream\r\n    }),\r\n    [createFromReadableStream, payload, fetchImplementation, getContext]\r\n  );\r\n  React3.useEffect(() => {\r\n    setIsHydrated();\r\n  }, []);\r\n  React3.useLayoutEffect(() => {\r\n    const globalVar = window;\r\n    if (!globalVar.__routerInitialized) {\r\n      globalVar.__routerInitialized = true;\r\n      globalVar.__reactRouterDataRouter.initialize();\r\n    }\r\n  }, []);\r\n  let [{ routes, state }, setState] = React3.useState(() => ({\r\n    routes: cloneRoutes(router2.routes),\r\n    state: router2.state\r\n  }));\r\n  React3.useLayoutEffect(\r\n    () => router2.subscribe((newState) => {\r\n      if (diffRoutes(router2.routes, routes))\r\n        React3.startTransition(() => {\r\n          setState({\r\n            routes: cloneRoutes(router2.routes),\r\n            state: newState\r\n          });\r\n        });\r\n    }),\r\n    [router2.subscribe, routes, router2]\r\n  );\r\n  const transitionEnabledRouter = React3.useMemo(\r\n    () => ({\r\n      ...router2,\r\n      state,\r\n      routes\r\n    }),\r\n    [router2, routes, state]\r\n  );\r\n  React3.useEffect(() => {\r\n    if (routeDiscovery === \"lazy\" || // @ts-expect-error - TS doesn't know about this yet\r\n    window.navigator?.connection?.saveData === true) {\r\n      return;\r\n    }\r\n    function registerElement(el) {\r\n      let path = el.tagName === \"FORM\" ? el.getAttribute(\"action\") : el.getAttribute(\"href\");\r\n      if (!path) {\r\n        return;\r\n      }\r\n      let pathname = el.tagName === \"A\" ? el.pathname : new URL(path, window.location.origin).pathname;\r\n      if (!discoveredPaths.has(pathname)) {\r\n        nextPaths.add(pathname);\r\n      }\r\n    }\r\n    async function fetchPatches() {\r\n      document.querySelectorAll(\"a[data-discover], form[data-discover]\").forEach(registerElement);\r\n      let paths = Array.from(nextPaths.keys()).filter((path) => {\r\n        if (discoveredPaths.has(path)) {\r\n          nextPaths.delete(path);\r\n          return false;\r\n        }\r\n        return true;\r\n      });\r\n      if (paths.length === 0) {\r\n        return;\r\n      }\r\n      try {\r\n        await fetchAndApplyManifestPatches(\r\n          paths,\r\n          createFromReadableStream,\r\n          fetchImplementation\r\n        );\r\n      } catch (e) {\r\n        console.error(\"Failed to fetch manifest patches\", e);\r\n      }\r\n    }\r\n    let debouncedFetchPatches = debounce(fetchPatches, 100);\r\n    fetchPatches();\r\n    let observer = new MutationObserver(() => debouncedFetchPatches());\r\n    observer.observe(document.documentElement, {\r\n      subtree: true,\r\n      childList: true,\r\n      attributes: true,\r\n      attributeFilter: [\"data-discover\", \"href\", \"action\"]\r\n    });\r\n  }, [routeDiscovery, createFromReadableStream, fetchImplementation]);\r\n  const frameworkContext = {\r\n    future: {\r\n      // These flags have no runtime impact so can always be false.  If we add\r\n      // flags that drive runtime behavior they'll need to be proxied through.\r\n      v8_middleware: false,\r\n      unstable_subResourceIntegrity: false,\r\n      unstable_trailingSlashAwareDataRequests: true\r\n      // always on for RSC\r\n    },\r\n    isSpaMode: false,\r\n    ssr: true,\r\n    criticalCss: \"\",\r\n    manifest: {\r\n      routes: {},\r\n      version: \"1\",\r\n      url: \"\",\r\n      entry: {\r\n        module: \"\",\r\n        imports: []\r\n      }\r\n    },\r\n    routeDiscovery: { mode: \"lazy\", manifestPath: \"/__manifest\" },\r\n    routeModules\r\n  };\r\n  return /* @__PURE__ */ React3.createElement(RSCRouterContext.Provider, { value: true }, /* @__PURE__ */ React3.createElement(RSCRouterGlobalErrorBoundary, { location: state.location }, /* @__PURE__ */ React3.createElement(FrameworkContext.Provider, { value: frameworkContext }, /* @__PURE__ */ React3.createElement(\r\n    RouterProvider,\r\n    {\r\n      router: transitionEnabledRouter,\r\n      flushSync: ReactDOM2.flushSync\r\n    }\r\n  ))));\r\n}\r\nfunction createRouteFromServerManifest(match, payload) {\r\n  let hasInitialData = payload && match.id in payload.loaderData;\r\n  let initialData = payload?.loaderData[match.id];\r\n  let hasInitialError = payload?.errors && match.id in payload.errors;\r\n  let initialError = payload?.errors?.[match.id];\r\n  let isHydrationRequest = match.clientLoader?.hydrate === true || !match.hasLoader || // If the route has a component but we don't have an element, we need to hit\r\n  // the server loader flow regardless of whether the client loader calls\r\n  // `serverLoader` or not, otherwise we'll have nothing to render.\r\n  match.hasComponent && !match.element;\r\n  invariant(window.__reactRouterRouteModules);\r\n  populateRSCRouteModules(window.__reactRouterRouteModules, match);\r\n  let dataRoute = {\r\n    id: match.id,\r\n    element: match.element,\r\n    errorElement: match.errorElement,\r\n    handle: match.handle,\r\n    hasErrorBoundary: match.hasErrorBoundary,\r\n    hydrateFallbackElement: match.hydrateFallbackElement,\r\n    index: match.index,\r\n    loader: match.clientLoader ? async (args, singleFetch) => {\r\n      try {\r\n        let result = await match.clientLoader({\r\n          ...args,\r\n          serverLoader: () => {\r\n            preventInvalidServerHandlerCall(\r\n              \"loader\",\r\n              match.id,\r\n              match.hasLoader\r\n            );\r\n            if (isHydrationRequest) {\r\n              if (hasInitialData) {\r\n                return initialData;\r\n              }\r\n              if (hasInitialError) {\r\n                throw initialError;\r\n              }\r\n            }\r\n            return callSingleFetch(singleFetch);\r\n          }\r\n        });\r\n        return result;\r\n      } finally {\r\n        isHydrationRequest = false;\r\n      }\r\n    } : (\r\n      // We always make the call in this RSC world since even if we don't\r\n      // have a `loader` we may need to get the `element` implementation\r\n      (_, singleFetch) => callSingleFetch(singleFetch)\r\n    ),\r\n    action: match.clientAction ? (args, singleFetch) => match.clientAction({\r\n      ...args,\r\n      serverAction: async () => {\r\n        preventInvalidServerHandlerCall(\r\n          \"action\",\r\n          match.id,\r\n          match.hasLoader\r\n        );\r\n        return await callSingleFetch(singleFetch);\r\n      }\r\n    }) : match.hasAction ? (_, singleFetch) => callSingleFetch(singleFetch) : () => {\r\n      throw noActionDefinedError(\"action\", match.id);\r\n    },\r\n    path: match.path,\r\n    shouldRevalidate: match.shouldRevalidate,\r\n    // We always have a \"loader\" in this RSC world since even if we don't\r\n    // have a `loader` we may need to get the `element` implementation\r\n    hasLoader: true,\r\n    hasClientLoader: match.clientLoader != null,\r\n    hasAction: match.hasAction,\r\n    hasClientAction: match.clientAction != null,\r\n    hasShouldRevalidate: match.shouldRevalidate != null\r\n  };\r\n  if (typeof dataRoute.loader === \"function\") {\r\n    dataRoute.loader.hydrate = shouldHydrateRouteLoader(\r\n      match.id,\r\n      match.clientLoader,\r\n      match.hasLoader,\r\n      false\r\n    );\r\n  }\r\n  return dataRoute;\r\n}\r\nfunction callSingleFetch(singleFetch) {\r\n  invariant(typeof singleFetch === \"function\", \"Invalid singleFetch parameter\");\r\n  return singleFetch();\r\n}\r\nfunction preventInvalidServerHandlerCall(type, routeId, hasHandler) {\r\n  if (!hasHandler) {\r\n    let fn = type === \"action\" ? \"serverAction()\" : \"serverLoader()\";\r\n    let msg = `You are trying to call ${fn} on a route that does not have a server ${type} (routeId: \"${routeId}\")`;\r\n    console.error(msg);\r\n    throw new ErrorResponseImpl(400, \"Bad Request\", new Error(msg), true);\r\n  }\r\n}\r\nvar nextPaths = /* @__PURE__ */ new Set();\r\nvar discoveredPathsMaxSize = 1e3;\r\nvar discoveredPaths = /* @__PURE__ */ new Set();\r\nvar URL_LIMIT = 7680;\r\nfunction getManifestUrl(paths) {\r\n  if (paths.length === 0) {\r\n    return null;\r\n  }\r\n  if (paths.length === 1) {\r\n    return new URL(`${paths[0]}.manifest`, window.location.origin);\r\n  }\r\n  const globalVar = window;\r\n  let basename = (globalVar.__reactRouterDataRouter.basename ?? \"\").replace(\r\n    /^\\/|\\/$/g,\r\n    \"\"\r\n  );\r\n  let url = new URL(`${basename}/.manifest`, window.location.origin);\r\n  url.searchParams.set(\"paths\", paths.sort().join(\",\"));\r\n  return url;\r\n}\r\nasync function fetchAndApplyManifestPatches(paths, createFromReadableStream, fetchImplementation, signal) {\r\n  let url = getManifestUrl(paths);\r\n  if (url == null) {\r\n    return;\r\n  }\r\n  if (url.toString().length > URL_LIMIT) {\r\n    nextPaths.clear();\r\n    return;\r\n  }\r\n  let response = await fetchImplementation(new Request(url, { signal }));\r\n  if (!response.body || response.status < 200 || response.status >= 300) {\r\n    throw new Error(\"Unable to fetch new route matches from the server\");\r\n  }\r\n  let payload = await createFromReadableStream(response.body, {\r\n    temporaryReferences: void 0\r\n  });\r\n  if (payload.type !== \"manifest\") {\r\n    throw new Error(\"Failed to patch routes\");\r\n  }\r\n  paths.forEach((p) => addToFifoQueue(p, discoveredPaths));\r\n  React3.startTransition(() => {\r\n    payload.patches.forEach((p) => {\r\n      window.__reactRouterDataRouter.patchRoutes(\r\n        p.parentId ?? null,\r\n        [createRouteFromServerManifest(p)]\r\n      );\r\n    });\r\n  });\r\n}\r\nfunction addToFifoQueue(path, queue) {\r\n  if (queue.size >= discoveredPathsMaxSize) {\r\n    let first = queue.values().next().value;\r\n    if (typeof first === \"string\") queue.delete(first);\r\n  }\r\n  queue.add(path);\r\n}\r\nfunction debounce(callback, wait) {\r\n  let timeoutId;\r\n  return (...args) => {\r\n    window.clearTimeout(timeoutId);\r\n    timeoutId = window.setTimeout(() => callback(...args), wait);\r\n  };\r\n}\r\nfunction isExternalLocation(location2) {\r\n  const newLocation = new URL(location2, window.location.href);\r\n  return newLocation.origin !== window.location.origin;\r\n}\r\nfunction cloneRoutes(routes) {\r\n  if (!routes) return void 0;\r\n  return routes.map((route) => ({\r\n    ...route,\r\n    children: cloneRoutes(route.children)\r\n  }));\r\n}\r\nfunction diffRoutes(a, b) {\r\n  if (a.length !== b.length) return true;\r\n  return a.some((route, index) => {\r\n    if (route.element !== b[index].element) return true;\r\n    if (route.errorElement !== b[index].errorElement)\r\n      return true;\r\n    if (route.hydrateFallbackElement !== b[index].hydrateFallbackElement)\r\n      return true;\r\n    if (route.hasErrorBoundary !== b[index].hasErrorBoundary)\r\n      return true;\r\n    if (route.hasLoader !== b[index].hasLoader) return true;\r\n    if (route.hasClientLoader !== b[index].hasClientLoader)\r\n      return true;\r\n    if (route.hasAction !== b[index].hasAction) return true;\r\n    if (route.hasClientAction !== b[index].hasClientAction)\r\n      return true;\r\n    return diffRoutes(route.children || [], b[index].children || []);\r\n  });\r\n}\r\n\r\n// lib/rsc/html-stream/browser.ts\r\nfunction getRSCStream() {\r\n  let encoder = new TextEncoder();\r\n  let streamController = null;\r\n  let rscStream = new ReadableStream({\r\n    start(controller) {\r\n      if (typeof window === \"undefined\") {\r\n        return;\r\n      }\r\n      let handleChunk = (chunk) => {\r\n        if (typeof chunk === \"string\") {\r\n          controller.enqueue(encoder.encode(chunk));\r\n        } else {\r\n          controller.enqueue(chunk);\r\n        }\r\n      };\r\n      window.__FLIGHT_DATA || (window.__FLIGHT_DATA = []);\r\n      window.__FLIGHT_DATA.forEach(handleChunk);\r\n      window.__FLIGHT_DATA.push = (chunk) => {\r\n        handleChunk(chunk);\r\n        return 0;\r\n      };\r\n      streamController = controller;\r\n    }\r\n  });\r\n  if (typeof document !== \"undefined\" && document.readyState === \"loading\") {\r\n    document.addEventListener(\"DOMContentLoaded\", () => {\r\n      streamController?.close();\r\n    });\r\n  } else {\r\n    streamController?.close();\r\n  }\r\n  return rscStream;\r\n}\r\nexport {\r\n  HydratedRouter,\r\n  RouterProvider2 as RouterProvider,\r\n  RSCHydratedRouter as unstable_RSCHydratedRouter,\r\n  createCallServer as unstable_createCallServer,\r\n  getRSCStream as unstable_getRSCStream\r\n};\r\n"],
  "mappings": "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",
  "names": ["_a", "_b"]
}
